---
title: "Divorce_TBMU"
author: "Thomas Merkling"
date: "11 July 2018"
output: html_document
---

```{r, warning = FALSE, message = FALSE, include = FALSE}
setwd("D:/Thomas/Google Drive/postdoc/FQRNT_murre_project/murre_data/TBMU-divorce")
```

```{r}
library(ggplot2)
library(tidyverse)
library(glmmTMB)
library(MuMIn)
library(corrplot)
library(arm)
library(DHARMa)
library(brms)
library(shinystan)
library(tidybayes)
```

loading brms model selection functions
```{r}
source(file = "brms_modsel_func.R")
```


# **1. Causes of divorce**

import data created with the master data
```{r}
TBMU_divorce = read.table("TBMU_Coats_divorce_data.csv", header = TRUE, sep = ",")
dim(TBMU_divorce) # 1624   20
```

for these analyses we are only interested in whether a pair remained together or divorced, so we'll discard all the mate switching due to an individual disappareance.
```{r}
TBMU_divorce = TBMU_divorce %>% filter(Outcome != "DEAD")
dim(TBMU_divorce) # 952  20
TBMU_divorce = TBMU_divorce %>% mutate(ProbDiv = if_else(Outcome == "DIV",1,0))
```

## Data exploration

data exploration: how many missing data for each 
```{r }
table(is.na(TBMU_divorce$Laying))
table(is.na(TBMU_divorce$Fledge))
table(is.na(TBMU_divorce$AgeMale))
table(is.na(TBMU_divorce$AgeFemale))
table(is.na(TBMU_divorce$AgeBird1))
table(is.na(TBMU_divorce$AgeBird2))
table(is.na(TBMU_divorce$ExpMale))
table(is.na(TBMU_divorce$ExpFemale))
table(is.na(TBMU_divorce$ExpBird1))
table(is.na(TBMU_divorce$ExpBird2))
table(is.na(TBMU_divorce$PairBond))
table(is.na(TBMU_divorce$QLTY))
```
it's mostly for age and breeding experience that there are missing values and for fledging a bit too

Create a new variable for the study plot. Some experiments have been carried out on J and small sample size for N, so will not consider those 2.
```{r}
TBMU_divorce_clean = TBMU_divorce %>% dplyr::select(c(-Hatching,-Outcome)) %>% na.omit() %>% mutate(Plot = substr(Site,1,1)) %>% filter(Plot != "N" & Plot != "J")
TBMU_divorce_clean$BandNo1 = factor(TBMU_divorce_clean$BandNo1)
TBMU_divorce_clean$BandNo2 = factor(TBMU_divorce_clean$BandNo2)
TBMU_divorce_clean$Site = factor(TBMU_divorce_clean$Site)
```
removing all the observations with at least one NA leaves 320 observations!

```{r}
TBMU_divorce_outExp = TBMU_divorce %>% dplyr::select(c(-Hatching,-Outcome,-ExpMale,-ExpFemale,-ExpBird1,-ExpBird2,-PairBond)) %>% na.omit() %>% mutate(Plot = substr(Site,1,1))  %>% filter(Plot != "N" & Plot != "J")
```
if I include observations with unreliable info about breeding experience and pair-bond, it yields ~140 more observations (but can't have those variables in the models)

Is there variability among years and/or among plots in divorce rates?
```{r}
div_Year = TBMU_divorce_outExp %>% group_by(Year) %>% summarise(PropDiv = mean(ProbDiv), SE_PropDiv = sd(ProbDiv)/sqrt(n()), N_Year = n())
div_Plot = TBMU_divorce_outExp %>% group_by(Plot) %>% summarise(PropDiv = mean(ProbDiv), SE_PropDiv = sd(ProbDiv)/sqrt(n()), N_Plot = n())
```
```{r, include=FALSE}
Year_graph = ggplot(data = div_Year, aes(x = Year, y = PropDiv)) + geom_point(aes(size = N_Year)) + geom_errorbar(aes(ymin = PropDiv - SE_PropDiv, ymax = PropDiv + SE_PropDiv)) + theme_bw()
```
```{r}
Year_graph
```
divorce rates seem slightly lower in recent years...

```{r, include=FALSE}
Plot_graph = ggplot(data = div_Plot, aes(x = Plot, y = PropDiv)) + geom_point(aes(size = N_Plot)) + geom_errorbar(aes(ymin = PropDiv - SE_PropDiv, ymax = PropDiv + SE_PropDiv)) + theme_bw()
```
```{r}
Plot_graph
```
huge variation among plots, with much lower divorce rates and larger sample size in the Q plot. We know that data quality is much higher for the Q plot, and the observed average divorce rate is closer to what we'd expect, so probably better to focus only on Q plot...

```{r}
TBMU_divorce_cleanQ = TBMU_divorce_clean %>% filter(Plot == "Q")
TBMU_divorce_outExpQ = TBMU_divorce_outExp %>% filter(Plot == "Q")
```

collinearity among explanatory variables
```{r}
cor_div = cor(TBMU_divorce_cleanQ[,c(5,7:8,11:12,15:16)])
corrplot.mixed(cor_div, upper = "ellipse", lower = "number")
```
Logically age and experience are strongly correlated within a sex, but otherwise no very strong correlations. So age and experience will never be in the same model.
We also know that reproductive success varies with age in this species, so is there some collinearity with Fledge?

```{r}
source(file = "HighstatLib.R") 
```
this is an R code containing functions created by Zuur et al.

```{r}
corvif(TBMU_divorce_cleanQ[,c(5:8,15:16)])
```
VIFs suggest that there is no multicollinearity between ages, laying date, fledging probability, pair-bond and site quality

loooking at spread of data for ages, breeding experience and pair-bond to see if I need to group data
```{r, include=FALSE}
Age_graph = ggplot(data = TBMU_divorce_cleanQ, aes(x = AgeMale)) + geom_histogram(fill = "blue", bins = 20, alpha = 0.4) + geom_histogram(aes(x = AgeFemale), fill = "red", bins = 20, alpha = 0.4) + geom_histogram(data = TBMU_divorce_outExpQ, aes(x = AgeMale), fill = "green", bins = 20, alpha = 0.4) + geom_histogram(data = TBMU_divorce_outExpQ, aes(x = AgeFemale), bins = 20, alpha = 0.4)
```
```{r}
Age_graph
```
maybe group 5 and less and 20+?

```{r, include=FALSE}
Exp_graph = ggplot(data = TBMU_divorce_cleanQ, aes(x = ExpMale)) + geom_histogram(fill = "blue", bins = 15, alpha = 0.4) + geom_histogram(aes(x = ExpFemale), fill = "red", bins = 15, alpha = 0.4)
```
```{r}
Exp_graph
```
maybe group 15+?

```{r, include=FALSE}
Bond_graph = ggplot(data = TBMU_divorce_cleanQ, aes(x = PairBond)) + geom_histogram(fill = "blue", bins = 12, alpha = 0.4)
```
```{r}
Bond_graph
```
maybe group 6+?

```{r, include=FALSE}
Laying_graph = ggplot(data = TBMU_divorce_cleanQ, aes(x = QLTY)) + geom_histogram(fill = "blue", bins = 12, alpha = 0.4)
```
```{r}
Laying_graph
```
maybe group dates > 50?

```{r, include=FALSE}
Qlty_graph = ggplot(data = TBMU_divorce_cleanQ, aes(x = QLTY)) + geom_histogram(fill = "blue", bins = 12, alpha = 0.4)
```
```{r}
Qlty_graph
```
maybe group qlty lower than 0.25?

## Grouping variables

sample size is quite small for the extreme values of ages, breeding experience and pair-bond, so I'll group them together. Had to play on where to group because of convergence issues!
to facilitate model convergence and allow a better comparison of effects across models, all the variables are standardised
I'm also creating variables to look at quadratic effects
```{r}
TBMU_divorce_cleanQ = TBMU_divorce_cleanQ %>% mutate_if(is.integer, as.numeric) %>% 
                            mutate(stdAgeMale = if_else(AgeMale >=22,22, if_else(AgeMale <= 5, 5, AgeMale)), stdAgeFemale = if_else(AgeFemale >= 22, 22, if_else(AgeFemale <= 5, 5, AgeFemale)), stdExpMale = if_else(ExpMale >= 11, 11, ExpMale), ExpFemale = if_else(ExpFemale >= 11, 11, ExpFemale), stdPairBond = if_else(PairBond >= 6, 6, PairBond), stdLaying = if_else(Laying >= 50,50, Laying), stdQlty = if_else(QLTY <= 0.25, 0.25, QLTY), PairID = factor(paste(BandNo1,BandNo2, sep = "_"))) %>%
                         mutate(stdAgeMale = arm::rescale(stdAgeMale), stdAgeFemale = rescale(stdAgeFemale), stdExpMale = rescale(stdExpMale), stdExpFemale = rescale(ExpFemale), stdPairBond = rescale(stdPairBond), stdQlty = rescale(stdQlty), stdFledge = rescale(Fledge), stdLaying = rescale(stdLaying),stdYear = rescale(Year)) %>% mutate(stdAgeMaleSq = I(stdAgeMale^2), stdAgeFemaleSq = I(stdAgeFemale^2), stdExpMaleSq = I(stdExpMale^2), stdExpFemaleSq = I(stdExpFemale^2), stdPairBondSq = I(stdPairBond^2), stdQltySq = I(stdQlty^2), stdLayingSq = I(stdLaying^2), stdYearSq = I(stdYear^2))
```

```{r}
TBMU_divorce_outExpQ = TBMU_divorce_outExpQ %>% mutate_if(is.integer, as.numeric)%>% 
           mutate(stdAgeMale = if_else(AgeMale >=22,22, if_else(AgeMale <= 5, 5, AgeMale)), stdAgeFemale = if_else(AgeFemale >= 22, 22, if_else(AgeFemale <= 5, 5, AgeFemale)), stdLaying = if_else(Laying >= 50,50, Laying), stdQlty = if_else(QLTY <= 0.25, 0.25, QLTY), PairID = factor(paste(BandNo1,BandNo2, sep = "_"))) %>%
             mutate(stdAgeMale = arm::rescale(stdAgeMale), stdAgeFemale = rescale(stdAgeFemale), stdQlty = rescale(QLTY), stdFledge = rescale(Fledge), stdLaying = rescale(Laying),stdYear = rescale(Year))%>%
        mutate(stdAgeMaleSq = I(stdAgeMale^2), stdAgeFemaleSq = I(stdAgeFemale^2), stdQltySq = I(stdQlty^2), stdLayingSq = I(stdLaying^2), stdYeaSq = I(stdYear^2))
```


## Bayesian models with brms

I won't consider interactions with more than 2 terms and not models with age and breeding experience together
Had some convergence issues when using lme4 or glmmTMB so moved to brms and a Bayesian framework ...

Following code found on the brms Github by #keesterbrugge I try to use list-column format as suggested in the R for Data Science book
```{r}
mod_divQ <- list(
  # main effect models
  m1 = ProbDiv ~ 0 + intercept + stdAgeFemale + (1|Year) + (1|Site) + (1|BandM) + (1|BandF),
  m2 = ProbDiv ~ 0 + intercept + stdAgeMale + (1|Year) + (1|Site) + (1|BandM) + (1|BandF),
  m3 = ProbDiv ~ 0 + intercept + stdExpFemale + (1|Year) + (1|Site) + (1|BandM) + (1|BandF),
  m4 = ProbDiv ~ 0 + intercept + stdExpMale + (1|Year) + (1|Site) + (1|BandM) + (1|BandF),
  m5 = ProbDiv ~ 0 + intercept + stdPairBond + (1|Year) + (1|Site) + (1|BandM) + (1|BandF),
  m6 = ProbDiv ~ 0 + intercept + stdFledge + (1|Year) + (1|Site) + (1|BandM) + (1|BandF),
  m7 = ProbDiv ~ 0 + intercept + stdQlty + (1|Year) + (1|Site) + (1|BandM) + (1|BandF),
  m8 = ProbDiv ~ 0 + intercept + stdLaying + (1|Year) + (1|Site) + (1|BandM) + (1|BandF),
  m9 = ProbDiv ~ 0 + intercept + stdYear + (1|Year) + (1|Site) + (1|BandM) + (1|BandF),
  m10 = ProbDiv ~ 0 + intercept + (1|Year) + (1|Site) + (1|BandM) + (1|BandF),
  # additive models
    # models with fledging probability
  m11 = ProbDiv ~ 0 + intercept + stdFledge + stdAgeMale + (1|Year) + (1|Site) + (1|BandM) + (1|BandF),
  m12 = ProbDiv ~ 0 + intercept + stdFledge + stdAgeFemale + (1|Year) + (1|Site) + (1|BandM) + (1|BandF),
  m13 = ProbDiv ~ 0 + intercept + stdFledge + stdExpMale + (1|Year) + (1|Site) + (1|BandM) + (1|BandF),
  m14 = ProbDiv ~ 0 + intercept + stdFledge + stdExpFemale + (1|Year) + (1|Site) + (1|BandM) + (1|BandF),
  m15 = ProbDiv ~ 0 + intercept + stdFledge + stdQlty + (1|Year) + (1|Site) + (1|BandM) + (1|BandF),
  m16 = ProbDiv ~ 0 + intercept + stdFledge + stdPairBond + (1|Year) + (1|Site) + (1|BandM) + (1|BandF),
  m17 = ProbDiv ~ 0 + intercept + stdFledge + stdLaying + (1|Year) + (1|Site) + (1|BandM) + (1|BandF),
    # models with fenale age
  m18 = ProbDiv ~ 0 + intercept + stdAgeMale + stdAgeFemale + (1|Year) + (1|Site) + (1|BandM) + (1|BandF),
  m19 = ProbDiv ~ 0 + intercept + stdQlty + stdAgeFemale + (1|Year) + (1|Site) + (1|BandM) + (1|BandF),
  m20 = ProbDiv ~ 0 + intercept + stdPairBond + stdAgeFemale + (1|Year) + (1|Site) + (1|BandM) + (1|BandF),
  m21 = ProbDiv ~ 0 + intercept + stdLaying + stdAgeFemale + (1|Year) + (1|Site) + (1|BandM) + (1|BandF),
    # models with male age
  m22 = ProbDiv ~ 0 + intercept + stdQlty + stdAgeMale + (1|Year) + (1|Site) + (1|BandM) + (1|BandF),
  m23 = ProbDiv ~ 0 + intercept + stdPairBond + stdAgeMale + (1|Year) + (1|Site) + (1|BandM) + (1|BandF),
  m24 = ProbDiv ~ 0 + intercept + stdLaying + stdAgeMale + (1|Year) + (1|Site) + (1|BandM) + (1|BandF),
    # models with fenale breeding experience
  m25 = ProbDiv ~ 0 + intercept + stdExpMale + stdExpFemale + (1|Year) + (1|Site) + (1|BandM) + (1|BandF),
  m26 = ProbDiv ~ 0 + intercept + stdQlty + stdExpFemale + (1|Year) + (1|Site) + (1|BandM) + (1|BandF),
  m27 = ProbDiv ~ 0 + intercept + stdPairBond + stdExpFemale + (1|Year) + (1|Site) + (1|BandM) + (1|BandF),
  m28 = ProbDiv ~ 0 + intercept + stdLaying + stdExpFemale + (1|Year) + (1|Site) + (1|BandM) + (1|BandF),
    # models with male breeding experience
  m29 = ProbDiv ~ 0 + intercept + stdQlty + stdExpMale + (1|Year) + (1|Site) + (1|BandM) + (1|BandF),
  m30 = ProbDiv ~ 0 + intercept + stdPairBond + stdExpMale + (1|Year) + (1|Site) + (1|BandM) + (1|BandF),
  m31 = ProbDiv ~ 0 + intercept + stdLaying + stdExpMale + (1|Year) + (1|Site) + (1|BandM) + (1|BandF),
    # models with paid-bond
  m32 = ProbDiv ~ 0 + intercept + stdPairBond + stdQlty + (1|Year) + (1|Site) + (1|BandM) + (1|BandF),
  m33 = ProbDiv ~ 0 + intercept + stdPairBond + stdLaying + (1|Year) + (1|Site) + (1|BandM) + (1|BandF),
    # models with site quality
  m34 = ProbDiv ~ 0 + intercept + stdQlty + stdLaying + (1|Year) + (1|Site) + (1|BandM) + (1|BandF),
  # models with quadratic effects
  m35 = ProbDiv ~ 0 + intercept + stdAgeMale + stdAgeMaleSq + (1|Year) + (1|Site) + (1|BandM) + (1|BandF),
  m36 = ProbDiv ~ 0 + intercept + stdAgeFemale + stdAgeFemaleSq + (1|Year) + (1|Site) + (1|BandM) + (1|BandF),
  m37 = ProbDiv ~ 0 + intercept + stdExpMale + stdExpMaleSq + (1|Year) + (1|Site) + (1|BandM) + (1|BandF),
  m38 = ProbDiv ~ 0 + intercept + stdExpFemale + stdExpFemaleSq + (1|Year) + (1|Site) + (1|BandM) + (1|BandF),
  m39 = ProbDiv ~ 0 + intercept + stdQlty + stdQltySq + (1|Year) + (1|Site) + (1|BandM) + (1|BandF),
  m40 = ProbDiv ~ 0 + intercept + stdPairBond + stdPairBondSq + (1|Year) + (1|Site) + (1|BandM) + (1|BandF),
  m41 = ProbDiv ~ 0 + intercept + stdLaying + stdLayingSq + (1|Year) + (1|Site) + (1|BandM) + (1|BandF),
  # models with two-way interactions
    # models with fledging probability
  m42 = ProbDiv ~ 0 + intercept + stdFledge * stdAgeMale + (1|Year) + (1|Site) + (1|BandM) + (1|BandF),
  m43 = ProbDiv ~ 0 + intercept + stdFledge * stdAgeFemale + (1|Year) + (1|Site) + (1|BandM) + (1|BandF),
  m44 = ProbDiv ~ 0 + intercept + stdFledge * stdExpMale + (1|Year) + (1|Site) + (1|BandM) + (1|BandF),
  m45 = ProbDiv ~ 0 + intercept + stdFledge * stdExpFemale + (1|Year) + (1|Site) + (1|BandM) + (1|BandF),
  m46 = ProbDiv ~ 0 + intercept + stdFledge * stdQlty + (1|Year) + (1|Site) + (1|BandM) + (1|BandF),
  m47 = ProbDiv ~ 0 + intercept + stdFledge * stdPairBond + (1|Year) + (1|Site) + (1|BandM) + (1|BandF),
  m48 = ProbDiv ~ 0 + intercept + stdFledge * stdLaying + (1|Year) + (1|Site) + (1|BandM) + (1|BandF),
    # models with fenale age
  m49 = ProbDiv ~ 0 + intercept + stdAgeMale * stdAgeFemale + (1|Year) + (1|Site) + (1|BandM) + (1|BandF),
  m50 = ProbDiv ~ 0 + intercept + stdQlty * stdAgeFemale + (1|Year) + (1|Site) + (1|BandM) + (1|BandF),
  m51 = ProbDiv ~ 0 + intercept + stdPairBond * stdAgeFemale + (1|Year) + (1|Site) + (1|BandM) + (1|BandF),
  m52 = ProbDiv ~ 0 + intercept + stdLaying * stdAgeFemale + (1|Year) + (1|Site) + (1|BandM) + (1|BandF),
    # models with male age
  m53 = ProbDiv ~ 0 + intercept + stdQlty * stdAgeMale + (1|Year) + (1|Site) + (1|BandM) + (1|BandF),
  m54 = ProbDiv ~ 0 + intercept + stdPairBond * stdAgeMale + (1|Year) + (1|Site) + (1|BandM) + (1|BandF),
  m55 = ProbDiv ~ 0 + intercept + stdLaying * stdAgeMale + (1|Year) + (1|Site) + (1|BandM) + (1|BandF),
    # models with fenale breeding experience
  m56 = ProbDiv ~ 0 + intercept + stdExpMale * stdExpFemale + (1|Year) + (1|Site) + (1|BandM) + (1|BandF),
  m57 = ProbDiv ~ 0 + intercept + stdQlty * stdExpFemale + (1|Year) + (1|Site) + (1|BandM) + (1|BandF),
  m58 = ProbDiv ~ 0 + intercept + stdPairBond * stdExpFemale + (1|Year) + (1|Site) + (1|BandM) + (1|BandF),
  m59 = ProbDiv ~ 0 + intercept + stdLaying * stdExpFemale + (1|Year) + (1|Site) + (1|BandM) + (1|BandF),
    # models with male age
  m60 = ProbDiv ~ 0 + intercept + stdQlty * stdExpMale + (1|Year) + (1|Site) + (1|BandM) + (1|BandF),
  m61 = ProbDiv ~ 0 + intercept + stdPairBond * stdExpMale + (1|Year) + (1|Site) + (1|BandM) + (1|BandF),
  m62 = ProbDiv ~ 0 + intercept + stdLaying * stdExpMale + (1|Year) + (1|Site) + (1|BandM) + (1|BandF),
    # models with paid-bond
  m63 = ProbDiv ~ 0 + intercept + stdPairBond * stdQlty + (1|Year) + (1|Site) + (1|BandM) + (1|BandF),
  m64 = ProbDiv ~ 0 + intercept + stdPairBond * stdLaying + (1|Year) + (1|Site) + (1|BandM) + (1|BandF),
  m65 = ProbDiv ~ 0 + intercept + stdQlty * stdLaying + (1|Year) + (1|Site) + (1|BandM) + (1|BandF)
  )
```

DO NOT RUN!! Load the data below
```{r}
divQ_data <- tibble( 
  name = names(mod_divQ),
  formulas = mod_divQ
  ) %>% 
  mutate(model = mod_divQ %>% purrr::map( 
      .f = brm, 
      data = TBMU_divorce_cleanQ, 
      family = bernoulli(),
      prior = c(set_prior("normal(0,5)", class = "b"), 
                set_prior("student_t(3,0,5)", class = "sd")),
      control = list(adapt_delta = 0.99),
      chains = 4, iter = 10000, warmup = 1000, thin = 5, cores = getOption("mc.cores", 4)))
```

m2k <- kfold(divQ_data$model$m2,divQ_data$model$m39, compare = TRUE, K = 10, chains = 2, cores = 4,save_fits = TRUE)

```{r}
save(divQ_data, file = "brms_divQ.Rdata")
```

```{r}
load(file = "brms_divQ.Rdata")
```

make sure the brms model selection function have been loaded
```{r}
divQ_table <-  waic_table(divQ_data)
```

```{r}
save(divQ_table, file = "brms_divQ_table.Rdata")
```

```{r}
load(file = "brms_divQ_table.Rdata")
```

subsetting models to keep the 95% confidence set and extracting the variables appearing at least once in that subset
```{r}
divQ_var <- sub_modvar(divQ_data, divQ_table)
```


ERROR in modavg function because some interaction models are in the subset but not the main effect models, which means that there are no models to estimate those main effects .. Need to fix code to estimate main effect from interaction model in this case

Also, very weird results with the order of the models ... need to check that!!!!

creating a table with model averaged posterior samples while controlling for interaction vs main effects issues
```{r}
divQ_modavg <- brm_mod_avg(divQ_var)
```

```{r}
write.table(divQ_modavg, "estimates_divQ_TBMU.csv",row.names = TRUE, sep = ",")
```





```{r}
summary(mod_brms)
plot(mod_brms)
#brms::launch_shinystan(mod_brms)
stanplot(mod_brms)
```





## Frequentist models (with convergence issues)

```{r}
mod_divQ = list()

## 2-way interactions with fledging probability
mod_divQ[[1]] = glmmTMB(ProbDiv ~ stdFledge * stdAgeMale + (1|Year) + (1|Site) + (1|PairID), family = "binomial", control = glmmTMBControl(optCtrl = list(iter.max = 1000, eval.max = 1000), profile = TRUE), data = TBMU_divorce_cleanQ)
mod_divQ[[2]] = glmmTMB(ProbDiv ~ stdFledge * stdAgeFemale + (1|Year) + (1|Site) + (1|PairID), family = "binomial",  data =  TBMU_divorce_cleanQ)
mod_divQ[[3]] = glmmTMB(ProbDiv ~ stdFledge * stdExpMale + (1|Year) + (1|Site) + (1|PairID), family = "binomial", control = glmmTMBControl(optCtrl = list(iter.max = 1000, eval.max = 1000), profile = TRUE), data =  TBMU_divorce_cleanQ)
mod_divQ[[4]] = glmmTMB(ProbDiv ~ stdFledge * stdExpFemale + (1|Year) + (1|Site) + (1|PairID), family = "binomial", data =  TBMU_divorce_cleanQ)
mod_divQ[[5]] = glmmTMB(ProbDiv ~ stdFledge * stdPairBond + (1|Year) + (1|Site) + (1|PairID), family = "binomial", data =  TBMU_divorce_cleanQ)
mod_divQ[[6]] = glmmTMB(ProbDiv ~ stdFledge * stdQlty + (1|Year) + (1|Site) + (1|PairID), family = "binomial", data =  TBMU_divorce_cleanQ)
mod_divQ[[7]] = glmmTMB(ProbDiv ~ stdFledge * stdLaying + (1|Year) + (1|Site) + (1|PairID), family = "binomial", data =  TBMU_divorce_cleanQ)

## 2-way interactions with male age
mod_divQ[[8]] = glmmTMB(ProbDiv ~ stdAgeMale * stdAgeFemale + (1|Year) + (1|Site) + (1|PairID), family = "binomial", control = glmmTMBControl(optCtrl = list(iter.max = 1000, eval.max = 1000), profile = TRUE), data =  TBMU_divorce_cleanQ)
mod_divQ[[9]] = glmmTMB(ProbDiv ~ stdAgeMale * stdPairBond + (1|Year) + (1|Site) + (1|PairID), family = "binomial", data =  TBMU_divorce_cleanQ)
mod_divQ[[10]] = glmmTMB(ProbDiv ~ stdAgeMale * stdQlty + (1|Year) + (1|Site) + (1|PairID), family = "binomial", data =  TBMU_divorce_cleanQ)
mod_divQ[[11]] = glmmTMB(ProbDiv ~ stdAgeMale * stdLaying + (1|Year) + (1|Site) + (1|PairID), family = "binomial", data =  TBMU_divorce_cleanQ)

## 2-way interactions with female age
mod_divQ[[12]] = glmmTMB(ProbDiv ~ stdAgeFemale * stdPairBond + (1|Year) + (1|Site) + (1|PairID), family = "binomial", data =  TBMU_divorce_cleanQ)
mod_divQ[[13]] = glmmTMB(ProbDiv ~ stdAgeFemale * stdQlty + (1|Year) + (1|Site) + (1|PairID), family = "binomial", data =  TBMU_divorce_cleanQ)
mod_divQ[[14]] = glmmTMB(ProbDiv ~ stdAgeFemale * stdLaying + (1|Year) + (1|Site) + (1|PairID), family = "binomial", data =  TBMU_divorce_cleanQ)

## 2-way interaction with male breeding experience
mod_divQ[[15]] = glmmTMB(ProbDiv ~ stdExpMale * stdExpFemale + (1|Year) + (1|Site) + (1|PairID), family = "binomial", data =  TBMU_divorce_cleanQ)
mod_divQ[[16]] = glmmTMB(ProbDiv ~ stdExpMale * stdPairBond + (1|Year) + (1|Site) + (1|PairID), family = "binomial", data =  TBMU_divorce_cleanQ)
mod_divQ[[17]] = glmmTMB(ProbDiv ~ stdExpMale * stdQlty + (1|Year) + (1|Site) + (1|PairID), family = "binomial", data =  TBMU_divorce_cleanQ)
mod_divQ[[18]] = glmmTMB(ProbDiv ~ stdExpMale * stdLaying + (1|Year) + (1|Site) + (1|PairID), family = "binomial", data =  TBMU_divorce_cleanQ)

## 2-way interactions with female breeding experience
mod_divQ[[19]] = glmmTMB(ProbDiv ~ stdExpFemale * stdPairBond + (1|Year) + (1|Site) + (1|PairID), family = "binomial", data =  TBMU_divorce_cleanQ)
mod_divQ[[20]] = glmmTMB(ProbDiv ~ stdExpFemale * stdQlty + (1|Year) + (1|Site) + (1|PairID), family = "binomial", data =  TBMU_divorce_cleanQ)
mod_divQ[[21]] = glmmTMB(ProbDiv ~ stdExpFemale * stdLaying + (1|Year) + (1|Site) + (1|PairID), family = "binomial", data =  TBMU_divorce_cleanQ)

## 2-way interactions with pair-bond duration
mod_divQ[[22]] = glmmTMB(ProbDiv ~ stdPairBond * stdQlty + (1|Year) + (1|Site) + (1|PairID), family = "binomial", data =  TBMU_divorce_cleanQ)
mod_divQ[[23]] = glmmTMB(ProbDiv ~ stdPairBond * stdLaying + (1|Year) + (1|Site) + (1|PairID), family = "binomial", data =  TBMU_divorce_cleanQ)

## 2-way interactions with site quality
#mod_divQ[[24]] = glmmTMB(ProbDiv ~ stdQlty * stdLaying + (1|Year) + (1|Site) + (1|PairID), family = "binomial", data =  TBMU_divorce_cleanQ) # doesn't converge...

## additive models with fledging probability
mod_divQ[[24]] = glmmTMB(ProbDiv ~ stdFledge + stdAgeMale + (1|Year) + (1|Site) + (1|PairID), family = "binomial", data =  TBMU_divorce_cleanQ)
mod_divQ[[25]] = glmmTMB(ProbDiv ~ stdFledge + stdAgeFemale + (1|Year) + (1|Site) + (1|PairID), family = "binomial", data =  TBMU_divorce_cleanQ)
mod_divQ[[26]] = glmmTMB(ProbDiv ~ stdFledge + stdExpMale + (1|Year) + (1|Site) + (1|PairID), family = "binomial", data =  TBMU_divorce_cleanQ)
mod_divQ[[27]] = glmmTMB(ProbDiv ~ stdFledge + stdExpFemale + (1|Year) + (1|Site) + (1|PairID), family = "binomial", data =  TBMU_divorce_cleanQ)
mod_divQ[[28]] = glmmTMB(ProbDiv ~ stdFledge + stdPairBond + (1|Year) + (1|Site) + (1|PairID), family = "binomial", data =  TBMU_divorce_cleanQ)
mod_divQ[[29]] = glmmTMB(ProbDiv ~ stdFledge + stdQlty + (1|Year) + (1|Site) + (1|PairID), family = "binomial",  data =  TBMU_divorce_cleanQ)
mod_divQ[[30]] = glmmTMB(ProbDiv ~ stdFledge + stdLaying + (1|Year) + (1|Site) + (1|PairID), family = "binomial", control = glmmTMBControl(optCtrl = list(iter.max = 1000, eval.max = 1000), profile = TRUE), data =  TBMU_divorce_cleanQ)

## additive models with male age
mod_divQ[[31]] = glmmTMB(ProbDiv ~ stdAgeMale + stdAgeFemale + (1|Year) + (1|Site) + (1|PairID), family = "binomial", data =  TBMU_divorce_cleanQ)
mod_divQ[[32]] = glmmTMB(ProbDiv ~ stdAgeMale + stdPairBond + (1|Year) + (1|Site) + (1|PairID), family = "binomial", data =  TBMU_divorce_cleanQ)
mod_divQ[[33]] = glmmTMB(ProbDiv ~ stdAgeMale + stdQlty + (1|Year) + (1|Site) + (1|PairID), family = "binomial", data =  TBMU_divorce_cleanQ)
mod_divQ[[34]] = glmmTMB(ProbDiv ~ stdAgeMale + stdLaying + (1|Year) + (1|Site) + (1|PairID), family = "binomial", data =  TBMU_divorce_cleanQ)

## additive models with female age
mod_divQ[[35]] = glmmTMB(ProbDiv ~ stdAgeFemale + stdPairBond + (1|Year) + (1|Site) + (1|PairID), family = "binomial", data =  TBMU_divorce_cleanQ)
mod_divQ[[36]] = glmmTMB(ProbDiv ~ stdAgeFemale + stdQlty + (1|Year) + (1|Site) + (1|PairID), family = "binomial", data =  TBMU_divorce_cleanQ)
mod_divQ[[37]] = glmmTMB(ProbDiv ~ stdAgeFemale + stdLaying + (1|Year) + (1|Site) + (1|PairID), family = "binomial", data =  TBMU_divorce_cleanQ)

## additive models with male breeding experience
mod_divQ[[38]] = glmmTMB(ProbDiv ~ stdExpMale + stdExpFemale + (1|Year) + (1|Site) + (1|PairID), family = "binomial", data =  TBMU_divorce_cleanQ)
mod_divQ[[39]] = glmmTMB(ProbDiv ~ stdExpMale + stdPairBond + (1|Year) + (1|Site) + (1|PairID), family = "binomial", data =  TBMU_divorce_cleanQ)
mod_divQ[[40]] = glmmTMB(ProbDiv ~ stdExpMale + stdQlty + (1|Year) + (1|Site) + (1|PairID), family = "binomial", data =  TBMU_divorce_cleanQ)
mod_divQ[[41]] = glmmTMB(ProbDiv ~ stdExpMale + stdLaying + (1|Year) + (1|Site) + (1|PairID), family = "binomial", data =  TBMU_divorce_cleanQ)

## additive models with female breeding experience
mod_divQ[[42]] = glmmTMB(ProbDiv ~ stdExpFemale + stdPairBond + (1|Year) + (1|Site) + (1|PairID), family = "binomial", data =  TBMU_divorce_cleanQ)
mod_divQ[[43]] = glmmTMB(ProbDiv ~ stdExpFemale + stdQlty + (1|Year) + (1|Site) + (1|PairID), family = "binomial", data =  TBMU_divorce_cleanQ)
mod_divQ[[44]] = glmmTMB(ProbDiv ~ stdExpFemale + stdLaying + (1|Year) + (1|Site) + (1|PairID), family = "binomial",  data =  TBMU_divorce_cleanQ)

## additive models with pair-bond duration
mod_divQ[[45]] = glmmTMB(ProbDiv ~ stdPairBond + stdQlty + (1|Year) + (1|Site) + (1|PairID), family = "binomial", data =  TBMU_divorce_cleanQ)
mod_divQ[[46]] = glmmTMB(ProbDiv ~ stdPairBond + stdLaying + (1|Year) + (1|Site) + (1|PairID), family = "binomial", data =  TBMU_divorce_cleanQ)

## additive models with site quality
#mod_divQ[[48]] = glmmTMB(ProbDiv ~ stdQlty + stdLaying + (1|Year) + (1|Site) + (1|PairID), family = "binomial", data =  TBMU_divorce_cleanQ)# doesn't converge

## models with quadratic effect
mod_divQ[[47]] = glmmTMB(ProbDiv ~ stdAgeMale + stdAgeMaleSq + (1|Year) + (1|Site) + (1|PairID), family = "binomial", data =  TBMU_divorce_cleanQ)
# mod_divQ[[50]] = glmmTMB(ProbDiv ~ stdAgeFemale + stdAgeFemaleSq + (1|Year) + (1|Site) + (1|PairID), family = "binomial", data =  TBMU_divorce_cleanQ)# doesn't converge
mod_divQ[[48]] = glmmTMB(ProbDiv ~ stdExpMale + stdExpMaleSq + (1|Year) + (1|Site) + (1|PairID), family = "binomial", data =  TBMU_divorce_cleanQ)
# mod_divQ[[52]] = glmmTMB(ProbDiv ~ stdExpFemale + stdExpFemaleSq + (1|Year) + (1|Site) + (1|PairID), family = "binomial", data =  TBMU_divorce_cleanQ)# doesn't converge
# mod_divQ[[53]] = glmmTMB(ProbDiv ~ stdQlty + stdQltySq + (1|Year) + (1|Site) + (1|PairID), family = "binomial", data =  TBMU_divorce_cleanQ)# doesn't converge
mod_divQ[[49]] = glmmTMB(ProbDiv ~ stdPairBond + stdPairBondSq + (1|Year) + (1|Site) + (1|PairID), family = "binomial", data =  TBMU_divorce_cleanQ)
mod_divQ[[50]] = glmmTMB(ProbDiv ~ stdLaying + stdLayingSq + (1|Year) + (1|Site) + (1|PairID), family = "binomial", data =  TBMU_divorce_cleanQ)

## single effects models
mod_divQ[[51]] = glmmTMB(ProbDiv ~ stdFledge + (1|Year) + (1|Site) + (1|PairID), family = "binomial", data =  TBMU_divorce_cleanQ)
mod_divQ[[52]] = glmmTMB(ProbDiv ~ stdAgeMale + (1|Year) + (1|Site) + (1|PairID), family = "binomial", data =  TBMU_divorce_cleanQ)
mod_divQ[[53]] = glmmTMB(ProbDiv ~ stdAgeFemale + (1|Year) + (1|Site) + (1|PairID), family = "binomial", data =  TBMU_divorce_cleanQ)
mod_divQ[[54]] = glmmTMB(ProbDiv ~ stdExpMale + (1|Year) + (1|Site) + (1|PairID), family = "binomial", data =  TBMU_divorce_cleanQ)
mod_divQ[[55]] = glmmTMB(ProbDiv ~ stdExpFemale + (1|Year) + (1|Site) + (1|PairID), family = "binomial", data =  TBMU_divorce_cleanQ)
mod_divQ[[56]] = glmmTMB(ProbDiv ~ stdPairBond + (1|Year) + (1|Site) + (1|PairID), family = "binomial", data =  TBMU_divorce_cleanQ)
mod_divQ[[57]] = glmmTMB(ProbDiv ~ stdQlty + (1|Year) + (1|Site) + (1|PairID), family = "binomial", data =  TBMU_divorce_cleanQ)
mod_divQ[[58]] = glmmTMB(ProbDiv ~ stdLaying + (1|Year) + (1|Site) + (1|PairID), family = "binomial", data =  TBMU_divorce_cleanQ)

mod_divQ[[59]] = glmmTMB(ProbDiv ~ stdYear + (1|Year) + (1|Site) + (1|PairID), family = "binomial", data =  TBMU_divorce_cleanQ)
#mod_divQ[[60]] = glmmTMB(ProbDiv ~ stdYear + stdYearSq + (1|Year) + (1|Site) + (1|PairID), family = "binomial", data =  TBMU_divorce_cleanQ) # doesn't converge
mod_divQ[[60]] = glmmTMB(ProbDiv ~ 1 + (1|Year) + (1|Site) + (1|PairID), family = "binomial", data =  TBMU_divorce_cleanQ)
```


Check simulated residuals using DHARMa package. Doesn't work with models in list
```{r}
mod_divQ_DHAR = glmmTMB(ProbDiv ~ stdExpFemale + stdExpMale + stdFledge + (1|Year) + (1|Site) + (1|BandNo1) + (1|BandNo2), family = "binomial", data =  TBMU_divorce_cleanQ)
summary(mod_divQ_DHAR)

divQ_simres <- simulateResiduals(mod_divQ_DHAR, n = 1000)

plot(divQ_simres)
```
Looks pretty good!

Ranking all the models in increasing order of AICc and taking a subset to get to 95% of cumulative weights
```{r}
AIC_div = model.sel(mod_divQ, rank = "AICc")
modavg_divD6 = model.avg(AIC_div, beta = "none", subset = delta <= 6)
modavg_divP95 = model.avg(AIC_div, beta = "none", subset = cumsum(weight) <.95)
```

```{r include = FALSE}
mod_div_EstimatesD6 = cbind(summary(modavg_divD6)$coefmat.subset[,c(1,3)], confint(modavg_divD6))
mod_div_EstimatesP95 = cbind(summary(modavg_divP95)$coefmat.subset[,c(1,3)], confint(modavg_divP95))
```

```{r echo = FALSE}
mod_div_EstimatesD6
```
there's a negative effect of age and breeding experience of both sexes and of site quality, while reproductive success, also influenced the probability of divorce but to a lesser extent. Pair-bond duration doesn't seem to affect divorce...

```{r echo = FALSE}
mod_div_EstimatesP95
```
when considering the 95% of cumulative weights, the effects are the same but they are slightly weaker

```{r}
write.table(mod_div_EstimatesD6,"estimates_D6_divorce_TBMU.csv", row.names = TRUE, sep = ",")
write.table(mod_div_EstimatesP95,"estimates_P95_divorce_TBMU.csv", row.names = TRUE, sep = ",")
```


## Representations of effects

effect of breeding experience
```{r}
div_Exp = TBMU_divorce_cleanQ %>% mutate(ExpFemale = if_else(ExpFemale >= 15, 15, ExpFemale)) %>% group_by(ExpFemale) %>% summarise(PropDivFemale = mean(ProbDiv), SE_PropDivFemale = sd(ProbDiv)/sqrt(n()), N_Female = n()) %>% rename(Exp = ExpFemale)
div_ExpM = TBMU_divorce_cleanQ %>% mutate(ExpMale = if_else(ExpMale >= 15, 15, ExpMale)) %>% group_by(ExpMale) %>% summarise(PropDivMale = mean(ProbDiv), SE_PropDivMale = sd(ProbDiv)/sqrt(n()), N_Male = n()) %>% rename(Exp = ExpMale)
div_Exp = full_join(div_Exp, div_ExpM, by = "Exp")
```

```{r include=FALSE}
plot_div_Exp = ggplot(data = div_Exp, aes(x = Exp)) + geom_point(aes(y = PropDivFemale, size = N_Female), colour = "red") + geom_errorbar(aes(ymax = PropDivFemale + SE_PropDivFemale, ymin = PropDivFemale - SE_PropDivFemale), colour = "red") +
  geom_point(aes(y = PropDivMale, size = N_Male), colour = "blue") + geom_errorbar(aes(ymax = PropDivMale + SE_PropDivMale, ymin = PropDivMale - SE_PropDivMale), colour = "blue") + theme_bw() + 
  theme(axis.text = element_text(size = 15), axis.title = element_text(size = 17), legend.position = "none",panel.grid.major=element_blank(), panel.grid.minor=element_blank()) + labs(x = "Breeding experience (years)", y = "Probability of divorce") 
```
```{r echo = FALSE}
plot_div_Exp
```

effect of age
```{r}
div_Age = TBMU_divorce_cleanQ %>% mutate(AgeFemale = if_else(AgeFemale <=5, 5, if_else(AgeFemale >= 20, 20, AgeFemale))) %>% group_by(AgeFemale) %>% summarise(PropDivFemale = mean(ProbDiv), SE_PropDivFemale = sd(ProbDiv)/sqrt(n()), N_Female = n()) %>% rename(Age = AgeFemale)
div_AgeM = TBMU_divorce_cleanQ %>% mutate(AgeMale = if_else(AgeMale <= 5, 5, if_else(AgeMale >= 20, 20, AgeMale))) %>% group_by(AgeMale) %>% summarise(PropDivMale = mean(ProbDiv), SE_PropDivMale = sd(ProbDiv)/sqrt(n()), N_Male = n()) %>% rename(Age = AgeMale)
div_Age = full_join(div_Age, div_AgeM, by = "Age")
```

```{r include=FALSE}
plot_div_Age = ggplot(data = div_Age, aes(x = Age)) + geom_point(aes(y = PropDivFemale, size = N_Female), colour = "red") + geom_errorbar(aes(ymax = PropDivFemale + SE_PropDivFemale, ymin = PropDivFemale - SE_PropDivFemale), colour = "red") +
  geom_point(aes(y = PropDivMale, size = N_Male), colour = "blue") + geom_errorbar(aes(ymax = PropDivMale + SE_PropDivMale, ymin = PropDivMale - SE_PropDivMale), colour = "blue") + theme_bw() + 
  theme(axis.text = element_text(size = 15), axis.title = element_text(size = 17), legend.position = "none",panel.grid.major=element_blank(), panel.grid.minor=element_blank()) + labs(x = "Age (years)", y = "Probability of divorce") 
```
```{r echo = FALSE}
plot_div_Age
```

because the effect of age is the same for both sex, I want to represent the combined effect ...
```{r}
TBMU_divorce_ageM = TBMU_divorce_cleanQ %>% dplyr::select (Site, Year, BandNo1, AgeMale, ProbDiv) %>% transmute(Site, Year, Band = BandNo1, Age = AgeMale, ProbDiv)
TBMU_divorce_ageF = TBMU_divorce_cleanQ %>% dplyr::select (Site, Year, BandNo2, AgeFemale, ProbDiv) %>% transmute(Site, Year, Band = BandNo2, Age = AgeFemale, ProbDiv)
TBMU_divorce_age = bind_rows(TBMU_divorce_ageF, TBMU_divorce_ageM)
TBMU_divorce_age$Site = factor(TBMU_divorce_age$Site)
TBMU_divorce_age$Band = factor(TBMU_divorce_age$Band)
```

had some issue with the predicted values when including random effects so used a glm but should fix this problem for publication!!
```{r}
mod_Age = glm(ProbDiv ~ Age, family = "binomial", data =  TBMU_divorce_age)
```

```{r}
dat_Age = data.frame(Age = seq(5,20, by = 1))
pred_Age = predict(mod_Age, dat_Age, se.fit = TRUE, type = "response")
dat_Age$fit = pred_Age$fit
dat_Age$se.fit = pred_Age$se.fit
```

```{r}
div_tot_Age = TBMU_divorce_age %>% mutate(Age = if_else(as.numeric(Age) <=5, 5, if_else(as.numeric(Age) >= 20, 20, as.numeric(Age)))) %>% group_by(Age) %>% summarise(mean_PropDiv = mean(ProbDiv), SE_PropDiv = sd(ProbDiv)/sqrt(n()), N = n())
```


```{r include=FALSE}
plot_div_tot_Age = ggplot(data = div_tot_Age, aes(x = Age)) + geom_point(aes(y = mean_PropDiv, size = N)) + geom_errorbar(aes(ymax = mean_PropDiv + SE_PropDiv, ymin = mean_PropDiv - SE_PropDiv))  + geom_line(data = dat_Age, aes(y = fit, x = Age), size = 2) + geom_line(data = dat_Age, aes(y = fit - se.fit, x = Age), lty =2) + geom_line(data = dat_Age, aes(y = fit + se.fit, x =  Age), lty = 2) +
  theme_bw() + 
  theme(axis.text = element_text(size = 50), axis.title = element_text(size = 50), legend.position = "none",panel.grid.major=element_blank(), panel.grid.minor=element_blank()) + labs(x = "Age (years)", y = "Probability of divorce") 
```
```{r echo = FALSE}
png("Divorce ~ Age.png", width = 1600, height = 960, units = "px")

plot_div_tot_Age
dev.off()
```



effect of reproductive success
```{r}
div_Fledge = TBMU_divorce_cleanQ %>% group_by(Fledge) %>% summarise(PropDiv = mean(ProbDiv), SE_PropDiv = sd(ProbDiv)/sqrt(n()), N = n())
```

```{r include=FALSE}
plot_div_Fledge = ggplot(data = div_Fledge, aes(x = factor(Fledge))) + geom_point(aes(y = PropDiv), size = 20) + geom_errorbar(aes(ymax = PropDiv + SE_PropDiv, ymin = PropDiv - SE_PropDiv), width = 0.2) + theme_bw() + 
  theme(axis.text = element_text(size = 50), axis.title = element_text(size = 50), legend.position = "none",panel.grid.major=element_blank(), panel.grid.minor=element_blank()) + labs(x = "Fledging success", y = "Probability of divorce") + scale_x_discrete(limits = c("0","1"),labels = c("NO","YES")) + annotate("text", x = 1, y = 0.15, label = 'N = 54', size = 20) + annotate("text", x = 2, y = 0.13, label = 'N = 169', size = 20)
```
```{r echo = FALSE}
png("Divorce ~ Fledge.png", width = 960, height = 960, units = "px")

plot_div_Fledge
dev.off()
```

effect of site quality
```{r}
div_Qlty = TBMU_divorce_cleanQ %>% group_by(QLTY) %>% summarise(PropDiv = mean(ProbDiv), SE_PropDiv = sd(ProbDiv)/sqrt(n()), N = n())
```

```{r include=FALSE}
plot_div_Qlty = ggplot(data = div_Qlty, aes(x = QLTY)) + geom_point(aes(y = PropDiv, size = N)) + geom_errorbar(aes(ymax = PropDiv + SE_PropDiv, ymin = PropDiv - SE_PropDiv), width = 0.2) + theme_bw() + 
  theme(axis.text = element_text(size = 15), axis.title = element_text(size = 17), legend.position = "none",panel.grid.major=element_blank(), panel.grid.minor=element_blank()) + labs(x = "Site quality", y = "Probability of divorce")
```
```{r echo = FALSE}
plot_div_Qlty
```


side analysis
does the probability of fledging success increase with pair-bond duration?
```{r}
fledge_pairBond = TBMU_divorce_cleanQ %>% mutate(PairBond = ifelse(PairBond >= 4, 4, PairBond)) %>% group_by(PairBond,ProbDiv) %>% summarise(ProbFledge = mean(Fledge), SE_ProbFledge = sd(Fledge)/sqrt(n()), N_ProbFledge = n())
fledge_pairBond$Divorce = as.factor(fledge_pairBond$ProbDiv)
```

```{r}
plot_fledge_pairBond = ggplot(data = fledge_pairBond, aes(x = PairBond, y = ProbFledge)) + geom_point(aes( fill = Divorce), size = 15, shape = 21) + geom_errorbar(aes(ymin = ProbFledge - SE_ProbFledge, ymax = ProbFledge + SE_ProbFledge), width = 0.2) + theme_bw() + 
  theme(axis.text = element_text(size = 50), axis.title = element_text(size = 50), legend.position = c(0.04,0.10),panel.grid.major=element_blank(), panel.grid.minor=element_blank()) + labs(x = "Pair-bond duration (years)", y = "Probability of fledging")
```

```{r}
png("Fledge ~ PairBond.png", width = 1600, height = 960, units = "px")

plot_fledge_pairBond
dev.off()
```



# **2. Outcomes of divorce**

## **a. Within-bird comparison before/after divorce**

```{r}
prepost_comp = read.table("prepost_div_comp_TBMU.csv", header = TRUE, sep = ",")
```

```{r}
prepost_comp$Band = factor(prepost_comp$Band)
```
only a few individuals appear twice in the data, so probably no need to include a random effect for ID

what is the range of age and breeding experience?
```{r, include = FALSE}
with(prepost_comp, hist(Age, breaks = 22))
```
only very few observations after 12 years...

```{r}
with(prepost_comp, hist(Exp, breaks = 10))
```
only very few observations after 6 years...

grouping extreme ages and breeding experiences
```{r}
prepost_comp = prepost_comp %>% mutate_if(is.integer, as.numeric) %>% mutate(Age = if_else(Age >= 12, 12, Age), Exp = if_else(Exp >= 6, 6, Exp))
```

Will look into the effect of age, breeding experience and sex of a focal bird on the difference between its old and new mate. As there are different missing values for the different response variables, I'll create a new subset for each analyses.

### Age difference

```{r}
age_prepost_comp = prepost_comp %>% dplyr::select(Band, Year, Band, Sex, Age, Exp, AgeDiff) %>% filter(!is.na(AgeDiff))
```

standardisation of the explanatory variables
```{r}
age_prepost_comp = age_prepost_comp %>% mutate(stdAge = rescale(Age), stdExp = rescale(Exp), stdSex = rescale(Sex))
```

how does the distribution of age difference look like
```{r}
with(age_prepost_comp, hist(AgeDiff, breaks = 20))
```
Not great ... will see how the residuals look like...

```{r}
mod_AgeDiff <- list(

AgeDiff1 = AgeDiff ~ 0 + intercept + stdSex * stdAge + (1|Year),
AgeDiff2 = AgeDiff ~ 0 + intercept + stdSex * stdExp + (1|Year),
AgeDiff3 = AgeDiff ~ 0 + intercept + stdSex + stdAge + (1|Year),
AgeDiff4 = AgeDiff ~ 0 + intercept + stdSex + stdExp + (1|Year),
AgeDiff5 = AgeDiff ~ 0 + intercept + stdSex + (1|Year),
AgeDiff6 = AgeDiff ~ 0 + intercept + stdAge + (1|Year),
AgeDiff7 = AgeDiff ~ 0 + intercept + stdExp + (1|Year),
AgeDiff8 = AgeDiff ~ 0 + intercept + (1|Year)
)
```

DO NOT RUN !! Load data instead
```{r}
#div_AgeDiff <- tibble( 
#  name = names(mod_AgeDiff),
#  formulas = mod_AgeDiff
#  ) %>% 
#  mutate(model = mod_AgeDiff %>% purrr::map( 
#      .f = brm, 
#      data = age_prepost_comp, 
#      family = gaussian,
#      prior = c(set_prior("normal(0,5)", class = "b"), 
#                set_prior("student_t(3,0,5)", class = "sd")),
#      control = list(adapt_delta = 0.99),
#      chains = 4, iter = 10000, warmup = 1000, thin = 5, cores = getOption("mc.cores", 1L)))
```

```{r}
#save(div_AgeDiff, file = "brms_div_AgeDiff.Rdata")
```

```{r}
load(file = "brms_div_AgeDiff.Rdata")
```

make sure the brms model selection function have been loaded
```{r}
divAgeDiff_table <-  waic_table(div_AgeDiff)
```
best model is the null model

subsetting models to keep the 95% confidence set and extracting the variables appearing at least once in that subset
```{r}
divAgeDiff_var <- sub_modvar(div_AgeDiff, divAgeDiff_table)
```

creating a table with model averaged posterior samples while controlling for interaction vs main effects issues
```{r}
divAgeDiff_modavg <- brm_mod_avg(divAgeDiff_var)
```

```{r}
write.table(divAgeDiff_modavg, "estimates_AgeDiff_TBMU.csv",row.names = TRUE, sep = ",")
```


#### glmmTMB analyses


```{r}
mod_AgeDiff = list()

mod_AgeDiff[[1]] = glmmTMB(AgeDiff ~ stdSex * stdAge + (1|Year), family = "gaussian", data = age_prepost_comp)
mod_AgeDiff[[2]] = glmmTMB(AgeDiff ~ stdSex * stdExp + (1|Year), family = "gaussian", data = age_prepost_comp)

mod_AgeDiff[[3]] = glmmTMB(AgeDiff ~ stdSex + stdAge + (1|Year), family = "gaussian", data = age_prepost_comp)
mod_AgeDiff[[4]] = glmmTMB(AgeDiff ~ stdSex + stdExp + (1|Year), family = "gaussian", data = age_prepost_comp)

mod_AgeDiff[[5]] = glmmTMB(AgeDiff ~ stdSex + (1|Year), family = "gaussian", data = age_prepost_comp)
mod_AgeDiff[[6]] = glmmTMB(AgeDiff ~ stdAge + (1|Year), family = "gaussian", data = age_prepost_comp)
mod_AgeDiff[[7]] = glmmTMB(AgeDiff ~ stdExp + (1|Year), family = "gaussian", data = age_prepost_comp)
mod_AgeDiff[[8]] = glmmTMB(AgeDiff ~ 1 + (1|Year), family = "gaussian", data = age_prepost_comp)
```

Ranking all the models in increasing order of AICc and taking a subset to get to 95% of cumulative weights
```{r}
AIC_AgeDiff = model.sel(mod_AgeDiff, rank = "AICc")
modavg_AgeDiffD6 = model.avg(mod_AgeDiff, beta = "none", subset = delta <= 6)
```

```{r, include=FALSE}
mod_AgeDiff_EstimatesD6 = cbind(summary(modavg_AgeDiffD6)$coefmat.subset[,c(1,3)], confint(modavg_AgeDiffD6))
```
```{r}
mod_AgeDiff_EstimatesD6
```
No efffect of any explanatory covariables or of the intercept ...

```{r}
#write.table(mod_AgeDiff_EstimatesD6, "estimates_D6_AgeDiff_TBMU.csv",row.names = TRUE, sep = ",")
```


### Breeding experience difference

```{r}
exp_prepost_comp = prepost_comp %>% dplyr::select(Band, Year, Band, Sex, Age, Exp, ExpDiff) %>% filter(!is.na(ExpDiff))
```

standardisation of the explanatory variables
```{r}
exp_prepost_comp = exp_prepost_comp %>% mutate(stdAge = rescale(Age), stdExp = rescale(Exp), stdSex = rescale(Sex))
```

how does the distribution of exp difference look like
```{r}
with(exp_prepost_comp, hist(ExpDiff, breaks = 20))
```
Not great ... will see how the residuals look like...

```{r}
mod_ExpDiff <- list(

ExpDiff1 = ExpDiff ~ 0 + intercept + stdSex * stdAge + (1|Year),
ExpDiff2 = ExpDiff ~ 0 + intercept + stdSex * stdExp + (1|Year),
ExpDiff3 = ExpDiff ~ 0 + intercept + stdSex + stdAge + (1|Year),
ExpDiff4 = ExpDiff ~ 0 + intercept + stdSex + stdExp + (1|Year),
ExpDiff5 = ExpDiff ~ 0 + intercept + stdSex + (1|Year),
ExpDiff6 = ExpDiff ~ 0 + intercept + stdAge + (1|Year),
ExpDiff7 = ExpDiff ~ 0 + intercept + stdExp + (1|Year),
ExpDiff8 = ExpDiff ~ 0 + intercept + (1|Year)
)
```

DO NOT RUN !! Load data instead
```{r}
#div_ExpDiff <- tibble( 
#  name = names(mod_ExpDiff),
#  formulas = mod_ExpDiff
#  ) %>% 
#  mutate(model = mod_ExpDiff %>% purrr::map( 
#      .f = brm, 
#      data = exp_prepost_comp, 
#      family = gaussian,
#      prior = c(set_prior("normal(0,5)", class = "b"), 
#                set_prior("student_t(3,0,5)", class = "sd")),
#      control = list(adapt_delta = 0.99),
#      chains = 4, iter = 10000, warmup = 1000, thin = 5, cores = getOption("mc.cores", 1L)))
```

```{r}
#save(div_ExpDiff, file = "brms_div_ExpDiff.Rdata")
```

```{r}
load(file = "brms_div_ExpDiff.Rdata")
```

make sure the brms model selection function have been loaded
```{r}
divExpDiff_table <-  waic_table(div_ExpDiff)
```
best model is the null model

subsetting models to keep the 95% confidence set and extracting the variables appearing at least once in that subset
```{r}
divExpDiff_var <- sub_modvar(div_ExpDiff, divExpDiff_table)
```

creating a table with model averaged posterior samples while controlling for interaction vs main effects issues
```{r}
divExpDiff_modavg <- brm_mod_avg(divExpDiff_var)
```

```{r}
write.table(divExpDiff_modavg, "estimates_ExpDiff_TBMU.csv",row.names = TRUE, sep = ",")
```


#### glmmTMB analyses

```{r}
mod_ExpDiff = list()

mod_ExpDiff[[1]] = glmmTMB(ExpDiff ~ stdSex * stdAge + (1|Year), family = "gaussian", data = exp_prepost_comp)
mod_ExpDiff[[2]] = glmmTMB(ExpDiff ~ stdSex * stdExp + (1|Year), family = "gaussian", data = exp_prepost_comp)

mod_ExpDiff[[3]] = glmmTMB(ExpDiff ~ stdSex + stdAge + (1|Year), family = "gaussian", data = exp_prepost_comp)
mod_ExpDiff[[4]] = glmmTMB(ExpDiff ~ stdSex + stdExp + (1|Year), family = "gaussian", data = exp_prepost_comp)

mod_ExpDiff[[5]] = glmmTMB(ExpDiff ~ stdSex + (1|Year), family = "gaussian", data = exp_prepost_comp)
mod_ExpDiff[[6]] = glmmTMB(ExpDiff ~ stdAge + (1|Year), family = "gaussian", data = exp_prepost_comp)
mod_ExpDiff[[7]] = glmmTMB(ExpDiff ~ stdExp + (1|Year), family = "gaussian", data = exp_prepost_comp)
mod_ExpDiff[[8]] = glmmTMB(ExpDiff ~ 1 + (1|Year), family = "gaussian", data = exp_prepost_comp)
```


Ranking all the models in increasing order of AICc and taking a subset to get to 95% of cumulative weights
```{r}
AIC_ExpDiff = model.sel(mod_ExpDiff, rank = "AICc")
modavg_ExpDiffD6 = model.avg(mod_ExpDiff, beta = "none", subset = delta <= 6)
```

```{r, include=FALSE}
mod_ExpDiff_EstimatesD6 = cbind(summary(modavg_ExpDiffD6)$coefmat.subset[,c(1,3)], confint(modavg_ExpDiffD6))
```
```{r}
mod_ExpDiff_EstimatesD6
```
No efffect of any explanatory covariables. The intercept isn't really different from zero ...

```{r}
#write.table(mod_ExpDiff_EstimatesD6, "estimates_D6_ExpDiff_TBMU.csv",row.names = TRUE, sep = ",")
```


### Site quality difference

```{r}
qlty_prepost_comp = prepost_comp %>% dplyr::select(Band, Year, Band, Sex, Age, Exp, Moved, QltyDiff) %>% filter(!is.na(QltyDiff))
```

standardisation of the explanatory variables
```{r}
qlty_prepost_comp = qlty_prepost_comp %>% mutate(stdAge = rescale(Age), stdExp = rescale(Exp), stdSex = rescale(Sex), binMoved = if_else(Moved == "YES", 1, 0))
```

did one sex move more after divorce?
```{r}
with(qlty_prepost_comp, table(Moved, Sex))
```
NO! Both sexes were equally likely to remain on site


```{r}
mod_MovedDiv <- list(

MovedDiv1 = binMoved ~ 0 + intercept + stdSex * stdAge + (1|Year),
MovedDiv2 = binMoved ~ 0 + intercept + stdExp * stdSex + (1|Year),
MovedDiv3 = binMoved ~ 0 + intercept + stdSex + stdAge + (1|Year),
MovedDiv4 = binMoved ~ 0 + intercept + stdSex + stdExp + (1|Year),
MovedDiv5 = binMoved ~ 0 + intercept + stdSex + (1|Year),
MovedDiv6 = binMoved ~ 0 + intercept + stdAge + (1|Year),
MovedDiv7 = binMoved ~ 0 + intercept + stdExp + (1|Year),
MovedDiv8 = binMoved ~ 0 + intercept + (1|Year)
)
```

DO NOT RUN !! Load data instead
```{r}
#div_MovedDiv <- tibble( 
#  name = names(mod_MovedDiv),
#  formulas = mod_MovedDiv
#  ) %>% 
#  mutate(model = mod_MovedDiv %>% purrr::map( 
#      .f = brm, 
#      data = qlty_prepost_comp, 
#      family = bernoulli(),
#      prior = c(set_prior("normal(0,5)", class = "b"), 
#                set_prior("student_t(3,0,5)", class = "sd")),
#      control = list(adapt_delta = 0.99),
#      chains = 4, iter = 10000, warmup = 1000, thin = 5, cores = getOption("mc.cores", 1L)))
```

```{r}
#save(div_MovedDiv, file = "brms_div_MovedDiv.Rdata")
```

```{r}
load(file = "brms_div_MovedDiv.Rdata")
```

make sure the brms model selection function have been loaded
```{r}
divMovedDiv_table <-  waic_table(div_MovedDiv)
```
best model is null model but experience and sex*experience very close

subsetting models to keep the 95% confidence set and extracting the variables appearing at least once in that subset
```{r}
divMovedDiv_var <- sub_modvar(div_MovedDiv, divMovedDiv_table)
```

creating a table with model averaged posterior samples while controlling for interaction vs main effects issues
```{r}
divMovedDiv_modavg <- brm_mod_avg(divMovedDiv_var)
```
there is an interaction between sex and breeding experience

```{r}
write.table(divMovedDiv_modavg, "estimates_MovedDiv_TBMU.csv",row.names = TRUE, sep = ",")
```

```{r}
SexExp_dat <- expand.grid(stdSex = unique(qlty_prepost_comp$stdSex), stdExp = unique(qlty_prepost_comp$stdExp), Year = unique(qlty_prepost_comp$Year))

SexExp_pred <- bind_cols(SexExp_dat, data.frame(predict(div_MovedDiv$model$MovedDiv2, newdata = SexExp_dat))) %>% group_by(stdSex, stdExp) %>% summarise(Est = mean(Estimate), SE = mean(Est.Error))
``` 


```{r}
aggr_moved = qlty_prepost_comp %>% group_by(stdSex, stdExp) %>% summarise(Mean = mean(binMoved), SE = sd(binMoved)/sqrt(n()), N = n())

ggplot(data = aggr_moved, aes(x = stdExp, y = Mean, colour = factor(stdSex))) + geom_point(aes(size=N)) + geom_line(data = SexExp_pred, aes(x = stdExp, y = Est, colour = factor(stdSex)))
```
Probability of moving increases with experience for females, but remains stable for males



Now focusing only on birds that moved
```{r}
movedY_qlty_prepost_comp = qlty_prepost_comp %>% filter(Moved == "YES")
```

how does the distribution of qlty difference look like
```{r}
with(movedY_qlty_prepost_comp, hist(QltyDiff, breaks = 20))
```
Not bad...

```{r}
mod_QltyDiff <- list(

QltyDiff1 = QltyDiff ~ 0 + intercept + stdSex * stdAge + (1|Year),
QltyDiff2 = QltyDiff ~ 0 + intercept + stdExp * stdSex + (1|Year),
QltyDiff3 = QltyDiff ~ 0 + intercept + stdSex + stdAge + (1|Year),
QltyDiff4 = QltyDiff ~ 0 + intercept + stdSex + stdExp + (1|Year),
QltyDiff5 = QltyDiff ~ 0 + intercept + stdSex + (1|Year),
QltyDiff6 = QltyDiff ~ 0 + intercept + stdAge + (1|Year),
QltyDiff7 = QltyDiff ~ 0 + intercept + stdExp + (1|Year),
QltyDiff8 = QltyDiff ~ 0 + intercept + (1|Year)
)
```


DO NOT RUN !! Load data instead
```{r}
div_QltyDiff <- tibble( 
  name = names(mod_QltyDiff),
  formulas = mod_QltyDiff
  ) %>% 
  mutate(model = mod_QltyDiff %>% purrr::map( 
      .f = brm, 
      data = movedY_qlty_prepost_comp, 
      family = gaussian,
      prior = c(set_prior("normal(0,5)", class = "b"), 
                set_prior("student_t(3,0,5)", class = "sd")),
      control = list(adapt_delta = 0.99),
      chains = 4, iter = 10000, warmup = 1000, thin = 5, cores = getOption("mc.cores", 1L)))
```

```{r}
save(div_QltyDiff, file = "brms_div_QltdyDiff.Rdata")
```

```{r}
load(file = "brms_div_QltdyDiff.Rdata")
```

make sure the brms model selection function have been loaded
```{r}
divQltyDiff_table <-  waic_table(div_QltyDiff)
```
best model with breeding experience

subsetting models to keep the 95% confidence set and extracting the variables appearing at least once in that subset
```{r}
divQltyDiff_var <- sub_modvar(div_QltyDiff, divQltyDiff_table)
```

creating a table with model averaged posterior samples while controlling for interaction vs main effects issues
```{r}
divQltyDiff_modavg <- brm_mod_avg(divQltyDiff_var)
```
weak positive effect of breeding experience: more experienced birds tend to move to a higher quality site after divorce

```{r}
write.table(divQltyDiff_modavg, "estimates_QltyDiff_TBMU.csv",row.names = TRUE, sep = ",")
```



#### glmmTMB analyses

```{r}
mod_MovedDiv = list()

mod_MovedDiv[[1]] = glmmTMB(binMoved ~ stdSex * stdAge + (1|Year), family = "binomial", data = qlty_prepost_comp)
mod_MovedDiv[[2]] = glmmTMB(binMoved ~ stdSex * stdExp + (1|Year), family = "binomial", data = qlty_prepost_comp)

mod_MovedDiv[[3]] = glmmTMB(binMoved ~ stdSex + stdAge + (1|Year), family = "binomial", data = qlty_prepost_comp)
mod_MovedDiv[[4]] = glmmTMB(binMoved ~ stdSex + stdExp + (1|Year), family = "binomial", data = qlty_prepost_comp)

mod_MovedDiv[[5]] = glmmTMB(binMoved ~ stdSex + (1|Year), family = "binomial", data = qlty_prepost_comp)
mod_MovedDiv[[6]] = glmmTMB(binMoved ~ stdAge + (1|Year), family = "binomial", data = qlty_prepost_comp)
mod_MovedDiv[[7]] = glmmTMB(binMoved ~ stdExp + (1|Year), family = "binomial", data = qlty_prepost_comp)
mod_MovedDiv[[8]] = glmmTMB(binMoved ~ 1 + (1|Year), family = "binomial", data = qlty_prepost_comp)
```

Ranking all the models in increasing order of AICc and taking a subset to get to 95% of cumulative weights
```{r}
library(MuMIn)
AIC_MovedDiv = model.sel(mod_MovedDiv, rank = "AICc")
modavg_MovedDivD6 = model.avg(mod_MovedDiv, beta = "none", subset = delta <= 6)
```

```{r, include=FALSE}
MovedDiv_EstimatesD6 = cbind(summary(modavg_MovedDivD6)$coefmat.subset[,c(1,3)], confint(modavg_MovedDivD6))
```
```{r}
MovedDiv_EstimatesD6
```
Interaction between experience and sex!

```{r}
aggr_moved = qlty_prepost_comp %>% group_by(Sex, Exp) %>% summarise(Mean = mean(binMoved), SE = sd(binMoved)/sqrt(n()), N = n())

ggplot(data = aggr_moved, aes(x = Exp, y = Mean, colour = Sex, size = N)) + geom_point()
```
Probability of moving increases with experience for females, but remains stable for males (or maybe a quadratic effect?)

```{r}
write.table(MovedDiv_EstimatesD6, "estimates_D6_MovedDiv_TBMU.csv",row.names = TRUE, sep = ",")
```

Now focusing only on birds that moved
```{r}
movedY_qlty_prepost_comp = qlty_prepost_comp %>% filter(Moved == "YES")
```

how does the distribution of qlty difference look like
```{r}
with(movedY_qlty_prepost_comp, hist(QltyDiff, breaks = 20))
```
Not bad...

```{r}
mod_QltyDiff = list()

mod_QltyDiff[[1]] = glmmTMB(QltyDiff ~ stdSex * stdAge + (1|Year), family = "gaussian", data = movedY_qlty_prepost_comp)
mod_QltyDiff[[2]] = glmmTMB(QltyDiff ~ stdSex * stdExp + (1|Year), family = "gaussian", data = movedY_qlty_prepost_comp)

mod_QltyDiff[[3]] = glmmTMB(QltyDiff ~ stdSex + stdAge + (1|Year), family = "gaussian", data = movedY_qlty_prepost_comp)
mod_QltyDiff[[4]] = glmmTMB(QltyDiff ~ stdSex + stdExp + (1|Year), family = "gaussian", data = movedY_qlty_prepost_comp)

mod_QltyDiff[[5]] = glmmTMB(QltyDiff ~ stdSex + (1|Year), family = "gaussian", data = movedY_qlty_prepost_comp)
mod_QltyDiff[[6]] = glmmTMB(QltyDiff ~ stdAge + (1|Year), family = "gaussian", data = movedY_qlty_prepost_comp)
mod_QltyDiff[[7]] = glmmTMB(QltyDiff ~ stdExp + (1|Year), family = "gaussian", data = movedY_qlty_prepost_comp)
mod_QltyDiff[[8]] = glmmTMB(QltyDiff ~ 1 + (1|Year), family = "gaussian", data = movedY_qlty_prepost_comp)
```

```{r}
hist(residuals(mod_QltyDiff[[8]], type = "pearson"))
```
looks alright

Ranking all the models in increasing order of AICc and taking a subset to get to 95% of cumulative weights
```{r}
AIC_QltyDiff = model.sel(mod_QltyDiff, rank = "AICc")
modavg_QltyDiffD6 = model.avg(mod_QltyDiff, beta = "none", subset = delta <= 6)
```

```{r, include=FALSE}
mod_QltyDiff_EstimatesD6 = cbind(summary(modavg_QltyDiffD6)$coefmat.subset[,c(1,3)], confint(modavg_QltyDiffD6))
```
```{r}
mod_QltyDiff_EstimatesD6
```
No efffect of any explanatory covariables. The intercept isn't different from zero ...

```{r}
write.table(mod_QltyDiff_EstimatesD6, "estimates_D6_QltyDiff_TBMU.csv",row.names = TRUE, sep = ",")
```


### Laying date difference

```{r}
lay_prepost_comp = prepost_comp %>% dplyr::select(Band, Year, Band, Sex, Age, Exp, LayingDiff) %>% filter(!is.na(LayingDiff))
```

standardisation of the explanatory variables
```{r}
lay_prepost_comp = lay_prepost_comp %>% mutate(stdAge = rescale(Age), stdExp = rescale(Exp), stdSex = rescale(Sex))
```

how does the distribution of lay difference look like
```{r}
with(lay_prepost_comp, hist(LayingDiff, breaks = 20))
```
Not great ... looks skewed towards negative values slightly

```{r}
mod_LayDiff = list()

mod_LayDiff[[1]] = glmmTMB(LayingDiff ~ stdSex * stdAge + (1|Year), family = "gaussian", data = lay_prepost_comp)
mod_LayDiff[[2]] = glmmTMB(LayingDiff ~ stdSex * stdExp + (1|Year), family = "gaussian", data = lay_prepost_comp)

mod_LayDiff[[3]] = glmmTMB(LayingDiff ~ stdSex + stdAge + (1|Year), family = "gaussian", data = lay_prepost_comp)
mod_LayDiff[[4]] = glmmTMB(LayingDiff ~ stdSex + stdExp + (1|Year), family = "gaussian", data = lay_prepost_comp)

mod_LayDiff[[5]] = glmmTMB(LayingDiff ~ stdSex + (1|Year), family = "gaussian", data = lay_prepost_comp)
mod_LayDiff[[6]] = glmmTMB(LayingDiff ~ stdAge + (1|Year), family = "gaussian", data = lay_prepost_comp)
mod_LayDiff[[7]] = glmmTMB(LayingDiff ~ stdExp + (1|Year), family = "gaussian", data = lay_prepost_comp)
mod_LayDiff[[8]] = glmmTMB(LayingDiff ~ 1 + (1|Year), family = "gaussian", data = lay_prepost_comp)
```

```{r}
hist(residuals(mod_LayDiff[[8]], type = "pearson"))
```
looks alright

Ranking all the models in increasing order of AICc and taking a subset to get to 95% of cumulative weights
```{r}
AIC_LayDiff = model.sel(mod_LayDiff, rank = "AICc")
modavg_LayDiffD6 = model.avg(mod_LayDiff, beta = "none", subset = delta <= 6)
```

```{r, include=FALSE}
mod_LayDiff_EstimatesD6 = cbind(summary(modavg_LayDiffD6)$coefmat.subset[,c(1,3)], confint(modavg_LayDiffD6))
```
```{r}
mod_LayDiff_EstimatesD6
```
No efffect of any explanatory covariables. The intercept isn't different from zero ...

```{r}
write.table(mod_LayDiff_EstimatesD6, "estimates_D6_LayDiff_TBMU.csv",row.names = TRUE, sep = ",")
```


### Reprod success difference

```{r}
fledge_prepost_comp = prepost_comp %>% dplyr::select(Band, Year, Band, Sex, Age, Exp, FledgeDiff) %>% filter(!is.na(FledgeDiff))
```

standardisation of the explanatory variables and recoding of response variable
```{r}
fledge_prepost_comp = fledge_prepost_comp %>% mutate(stdAge = rescale(Age), stdExp = rescale(Exp), stdSex = rescale(Sex), FledgeDiff = if_else(FledgeDiff == -1, 0, if_else(FledgeDiff == 0, 0.5, 1)))
```

```{r}
FledgeWeights = rep(2, nrow(fledge_prepost_comp))
```

```{r}
mod_FledgeDiff = list()

mod_FledgeDiff[[1]] = glmmTMB(FledgeDiff ~ stdSex * stdAge + (1|Year), weights = FledgeWeights, family = "binomial", data = fledge_prepost_comp)
mod_FledgeDiff[[2]] = glmmTMB(FledgeDiff ~ stdSex * stdExp + (1|Year), weights = FledgeWeights, family = "binomial", data = fledge_prepost_comp)

mod_FledgeDiff[[3]] = glmmTMB(FledgeDiff ~ stdSex + stdAge + (1|Year), weights = FledgeWeights, family = "binomial", data = fledge_prepost_comp)
mod_FledgeDiff[[4]] = glmmTMB(FledgeDiff ~ stdSex + stdExp + (1|Year), weights = FledgeWeights, family = "binomial", data = fledge_prepost_comp)

mod_FledgeDiff[[5]] = glmmTMB(FledgeDiff ~ stdSex + (1|Year), weights = FledgeWeights, family = "binomial", data = fledge_prepost_comp)
mod_FledgeDiff[[6]] = glmmTMB(FledgeDiff ~ stdAge + (1|Year), weights = FledgeWeights, family = "binomial", data = fledge_prepost_comp)
mod_FledgeDiff[[7]] = glmmTMB(FledgeDiff ~ stdExp + (1|Year), weights = FledgeWeights, family = "binomial", data = fledge_prepost_comp)
mod_FledgeDiff[[8]] = glmmTMB(FledgeDiff ~ 1 + (1|Year), weights = FledgeWeights, family = "binomial", data = fledge_prepost_comp)
```

Check simulated residuals using DHARMa package. Doesn't work with models in list
```{r}
FledgeDiff_mod = glmmTMB(FledgeDiff ~ rescale(Year) + (1|Year), weights = FledgeWeights, family = "binomial", data = fledge_prepost_comp)
summary(FledgeDiff_mod)

FledgeDiff_simres <- simulateResiduals(FledgeDiff_mod, n = 1000)

plot(FledgeDiff_simres)
```
Regardless of the model used the residuals don't look good ... we might be missing an important explanatory variable!

Ranking all the models in increasing order of AICc and taking a subset to get to 95% of cumulative weights
```{r}
AIC_FledgeDiff = model.sel(mod_FledgeDiff, rank = "AICc")
modavg_FledgeDiffD6 = model.avg(mod_FledgeDiff, beta = "none", subset = delta <= 6)
```

```{r, include=FALSE}
mod_FledgeDiff_EstimatesD6 = cbind(summary(modavg_FledgeDiffD6)$coefmat.subset[,c(1,3)], confint(modavg_FledgeDiffD6))
```
```{r}
mod_FledgeDiff_EstimatesD6
```
No efffect of any explanatory covariables. The intercept isn't different from zero ...

```{r}
write.table(mod_FledgeDiff_EstimatesD6, "estimates_D6_FledgeDiff_TBMU.csv",row.names = TRUE, sep = ",")
```


combine all the intercepts of all the analyses to compare the different variables
```{r}
all_prepost_comp = data.frame(Response = c("Age","Breeding experience","Site quality","Laying date","Fledging success"), Intercept = rep(0,5), lowCI = rep(0,5), upCI = rep(0,5))
all_prepost_comp[1,c(2:4)] = mod_AgeDiff_EstimatesD6[1,c(1,3:4)]
all_prepost_comp[2,c(2:4)] = mod_ExpDiff_EstimatesD6[1,c(1,3:4)]
all_prepost_comp[3,c(2:4)] = mod_QltyDiff_EstimatesD6[1,c(1,3:4)]
all_prepost_comp[4,c(2:4)] = mod_LayDiff_EstimatesD6[1,c(1,3:4)]
all_prepost_comp[5,c(2:4)] = mod_FledgeDiff_EstimatesD6[1,c(1,3:4)]
```

```{r}
plot_comp = ggplot(data = all_prepost_comp, aes(y = Intercept, x = Response)) + geom_point(size = 15) + geom_errorbar(aes(ymax = lowCI, ymin = upCI), width = 0.2) + theme_bw() + 
  theme(axis.text = element_text(size = 50), axis.title = element_text(size = 50), legend.position = "none",panel.grid.major=element_blank(), panel.grid.minor=element_blank()) + labs(y = "Difference between new and old (divorced) mate", x = "Variable") + geom_hline(yintercept = 0, linetype = 2)  + coord_flip()
```

```{r}
png("Difference between new and old mate.png", width = 1600, height = 960, units = "px")

plot_comp
dev.off()
```


## **b. Cost of partner change: comparison divorced and widowed birds**

```{r}
widow_comp = read.table("widow_indiv_TBMU.csv", header = TRUE, sep = ",")
```

```{r}
widow_comp$Band = factor(widow_comp$Band)
widow_comp$Status = "WIDOWED"
widow_comp = widow_comp[,c(1:6, 12:18)]
```

need to combine it with the divorce data.
```{r}
div_comp = read.table("prepost_div_comp_TBMU.csv", header = TRUE, sep = ",")
```

```{r}
div_comp$Band = factor(div_comp$Band)
div_comp$Status = "DIVORCED"
div_comp = div_comp[,c(1:6, 12:18)]
```

```{r}
widow_div_comp = bind_rows(div_comp,widow_comp) %>% mutate_if(is.character, as.factor)
```

inspect variation in differences between new and old mates
```{r}
hist(widow_div_comp$AgeDiff, breaks = 30)
```
```{r}
hist(widow_div_comp$ExpDiff, breaks = 30)
```
one extreme positive value!

```{r}
hist(widow_div_comp$QltyDiff, breaks = 20)
```
most individuals did not change

```{r}
hist(widow_div_comp$LayingDiff, breaks = 30)
```
```{r}
hist(widow_div_comp$FledgeDiff)
```

Will need to have Year, Band and Site as random effects

Goal is to look at whether there is a difference between divorced birds and widowed concerning who they remate with and whether it is sex-specific

### Age difference

```{r}
age_widiv_comp = widow_div_comp %>% dplyr::select(Band, Year, Site, Sex, Age, AgeDiff, Status) %>% filter(!is.na(AgeDiff))
```

standardisation of the explanatory variables
```{r}
library(arm)
age_widiv_comp = age_widiv_comp %>% mutate(stdSex = rescale(Sex), stdStatus = rescale(Status))
```

how does the distribution of age difference look like
```{r}
with(age_widiv_comp, hist(AgeDiff, breaks = 20))
```
Will have to be careful about the extreme positive age differences

Having Year, Site and Band as random effects caused some convergence issues, so I don't consider Site as it has a variance almost equal to zero.
```{r}
widiv_AgeDiff = list()

library(glmmTMB)
widiv_AgeDiff[[1]] = glmmTMB(AgeDiff ~ stdSex * stdStatus + (1|Year) + (1|Band), family = "gaussian", data = age_widiv_comp)
widiv_AgeDiff[[2]] = glmmTMB(AgeDiff ~ stdSex + stdStatus + (1|Year) + (1|Band), family = "gaussian", data = age_widiv_comp)
widiv_AgeDiff[[3]] = glmmTMB(AgeDiff ~ stdSex +  (1|Year) + (1|Band), family = "gaussian", data = age_widiv_comp)
widiv_AgeDiff[[4]] = glmmTMB(AgeDiff ~ stdStatus +  (1|Year) + (1|Band), family = "gaussian", data = age_widiv_comp)
widiv_AgeDiff[[5]] = glmmTMB(AgeDiff ~ 1 + (1|Year) +  (1|Band), family = "gaussian", data = age_widiv_comp)
```

```{r}
hist(residuals(widiv_AgeDiff[[1]], type = "pearson"))
```
looks alright

Ranking all the models in increasing order of AICc and taking a subset to get to 95% of cumulative weights
```{r}
library(MuMIn)
AIC_widiv_AgeDiff = model.sel(widiv_AgeDiff, rank = "AICc")
modavg_widiv_AgeDiffD6 = model.avg(widiv_AgeDiff, beta = "none", subset = delta <= 6)
```

```{r, include=FALSE}
widiv_AgeDiff_EstimatesD6 = cbind(summary(modavg_widiv_AgeDiffD6)$coefmat.subset[,c(1,3)], confint(modavg_widiv_AgeDiffD6))
```
```{r}
widiv_AgeDiff_EstimatesD6
```
Borderline egative effect of status! Widowed birds remate with younger birds than their previous partner as compared to divorced birds, probably because they are older...

```{r}
boxplot(Age ~ Status, data = age_widiv_comp)
```
Indeed, widowing happens later in life.

```{r}
write.table(widiv_AgeDiff_EstimatesD6, "estimates_D6_widiv_AgeDiff_TBMU.csv",row.names = TRUE, sep = ",")
```



### Breeding experience difference

```{r}
exp_widiv_comp = widow_div_comp %>% dplyr::select(Band, Year, Site, Sex, Exp, ExpDiff, Status) %>% filter(!is.na(ExpDiff))
```

standardisation of the explanatory variables
```{r}
library(arm)
exp_widiv_comp = exp_widiv_comp %>% mutate(stdSex = rescale(Sex), stdStatus = rescale(Status))
```

how does the distribution of age difference look like
```{r}
with(exp_widiv_comp, hist(ExpDiff, breaks = 20))
```
only a few large positive differences
Some convergence issues with the Status model, try to group positive differences
```{r}
exp_widiv_comp = exp_widiv_comp %>% mutate(ExpDiff = ifelse(ExpDiff >7, 8, ExpDiff))
```


Having Year, Site and Band as random effects caused some convergence issues, so I don't consider Site as it has a variance almost equal to zero.
```{r}
widiv_ExpDiff = list()

library(glmmTMB)
widiv_ExpDiff[[1]] = glmmTMB(ExpDiff ~ stdSex * stdStatus + (1|Year) + (1|Band), family = "gaussian", data = exp_widiv_comp)
widiv_ExpDiff[[2]] = glmmTMB(ExpDiff ~ stdSex + stdStatus + (1|Year) + (1|Band), family = "gaussian", data = exp_widiv_comp)
widiv_ExpDiff[[3]] = glmmTMB(ExpDiff ~ stdSex +  (1|Year) + (1|Band), family = "gaussian", data = exp_widiv_comp)
widiv_ExpDiff[[4]] = glmmTMB(ExpDiff ~ stdStatus +  (1|Year) + (1|Band), family = "gaussian", control = glmmTMBControl(optCtrl = list(iter.max = 1000, eval.max = 1000), profile = TRUE), data = exp_widiv_comp)
widiv_ExpDiff[[5]] = glmmTMB(ExpDiff ~ 1 + (1|Year) +  (1|Band), family = "gaussian", data = exp_widiv_comp)
```

```{r}
hist(residuals(widiv_ExpDiff[[1]], type = "pearson"))
```
looks alright

Ranking all the models in increasing order of AICc and taking a subset to get to 95% of cumulative weights
```{r}
library(MuMIn)
AIC_widiv_ExpDiff = model.sel(widiv_ExpDiff, rank = "AICc")
modavg_widiv_ExpDiffD6 = model.avg(widiv_ExpDiff, beta = "none", subset = delta <= 6)
```

```{r, include=FALSE}
widiv_ExpDiff_EstimatesD6 = cbind(summary(modavg_widiv_ExpDiffD6)$coefmat.subset[,c(1,3)], confint(modavg_widiv_ExpDiffD6))
```
```{r}
widiv_ExpDiff_EstimatesD6
```
Negative effect of Status! Widowed birds remate with less experienced birds than their previous partner as compared to divorced birds, probably because they are more experienced...

```{r}
boxplot(Exp ~ Status, data = exp_widiv_comp)
```
Indeed, widowing happens among more experienced individuals

```{r}
write.table(widiv_ExpDiff_EstimatesD6, "estimates_D6_widiv_ExpDiff_TBMU.csv",row.names = TRUE, sep = ",")
```


### Site quality difference

First looking at whether birds moved or not depends on sex and status and then focusing on those who moved

```{r}
qlty_widiv_comp = widow_div_comp %>% dplyr::select(Band, Year, Site, Sex, Age, Exp, QltyDiff, Moved, Status) %>% filter(!is.na(QltyDiff))
```

standardisation of the explanatory variables
```{r}
library(arm)
qlty_widiv_comp = qlty_widiv_comp %>% mutate(stdSex = rescale(Sex), stdAge = rescale(Age), stdYear = rescale(Year), stdStatus = rescale(Status), binMoved = if_else(Moved == "YES", 1, 0))
```

did individual move more after divorce?
```{r}
with(qlty_widiv_comp, table(Moved, Status))
```
YES! Probability of moving much higher after divorce than after widowing

```{r}
widiv_Moved = list()

library(glmmTMB)
widiv_Moved[[1]] = glmmTMB(binMoved ~ stdSex * stdStatus + (1|Year) + (1|Band) + (1|Site), family = "binomial", data = qlty_widiv_comp)
widiv_Moved[[2]] = glmmTMB(binMoved ~ stdSex + stdStatus + (1|Year) + (1|Band) + (1|Site), family = "binomial", data = qlty_widiv_comp)
widiv_Moved[[3]] = glmmTMB(binMoved ~ stdSex +  (1|Year) + (1|Band) + (1|Site), family = "binomial", data = qlty_widiv_comp)
widiv_Moved[[4]] = glmmTMB(binMoved ~ stdStatus +  (1|Year) + (1|Band) + (1|Site), family = "binomial", data = qlty_widiv_comp)
widiv_Moved[[5]] = glmmTMB(binMoved ~ stdAge +  (1|Year) + (1|Band) + (1|Site), family = "binomial", data = qlty_widiv_comp)
widiv_Moved[[6]] = glmmTMB(binMoved ~ stdYear +  (1|Year) + (1|Band) + (1|Site), family = "binomial", data = qlty_widiv_comp)
widiv_Moved[[7]] = glmmTMB(binMoved ~ 1 + (1|Year) +  (1|Band) + (1|Site), family = "binomial", data = qlty_widiv_comp)
```

Check simulated residuals using DHARMa package. Doesn't work with models in list
```{r}
Moved_mod = glmmTMB(binMoved ~ stdStatus +  (1|Year) + (1|Band) + (1|Site), family = "binomial", data = qlty_widiv_comp)
summary(Moved_mod)

Moved_simres <- simulateResiduals(Moved_mod, n = 1000)

plot(Moved_simres)
```
strong pattern in the residuals ...

Ranking all the models in increasing order of AICc and taking a subset to get to 95% of cumulative weights
```{r}
library(MuMIn)
AIC_widiv_Moved = model.sel(widiv_Moved, rank = "AICc")
modavg_widiv_MovedD6 = model.avg(widiv_Moved, beta = "none", subset = delta <= 6)
```

```{r, include=FALSE}
widiv_Moved_EstimatesD6 = cbind(summary(modavg_widiv_MovedD6)$coefmat.subset[,c(1,3)], confint(modavg_widiv_MovedD6))
```
```{r}
widiv_Moved_EstimatesD6
```
Negative effect of status: probability of moving lower for widowed birds

```{r}
write.table(widiv_Moved_EstimatesD6, "estimates_D6_widiv_Moved_TBMU.csv",row.names = TRUE, sep = ",")
```

Now focusing only on birds that moved
```{r}
movedY_qlty_widiv_comp = qlty_widiv_comp %>% filter(Moved == "YES")
```

how does the distribution of age difference look like
```{r}
with(movedY_qlty_widiv_comp, hist(QltyDiff, breaks = 20))
```

gives convergence issues with the 3 random effects, Year has very low variance so removed. Don't consider interaction because of low sample size
```{r}
widiv_QltyDiff = list()

library(glmmTMB)
#widiv_QltyDiff[[1]] = glmmTMB(QltyDiff ~ stdSex * stdStatus + (1|Band) + (1|Site), family = "gaussian", data = movedY_qlty_widiv_comp)
widiv_QltyDiff[[1]] = glmmTMB(QltyDiff ~ stdSex + stdStatus +  (1|Band) + (1|Site), family = "gaussian", data = movedY_qlty_widiv_comp)
widiv_QltyDiff[[2]] = glmmTMB(QltyDiff ~ stdSex +   (1|Band) + (1|Site), family = "gaussian", data = movedY_qlty_widiv_comp)
widiv_QltyDiff[[3]] = glmmTMB(QltyDiff ~ stdStatus +   (1|Band) + (1|Site), family = "gaussian", data = movedY_qlty_widiv_comp)
widiv_QltyDiff[[4]] = glmmTMB(QltyDiff ~ 1 + (1|Band) + (1|Site), family = "gaussian", data = movedY_qlty_widiv_comp)
```

```{r}
hist(residuals(widiv_QltyDiff[[1]], type = "pearson"))
```

Ranking all the models in increasing order of AICc and taking a subset to get to 95% of cumulative weights
```{r}
library(MuMIn)
AIC_widiv_QltyDiff = model.sel(widiv_QltyDiff, rank = "AICc")
modavg_widiv_QltyDiffD6 = model.avg(widiv_QltyDiff, beta = "none", subset = delta <= 6)
```

```{r, include=FALSE}
widiv_QltyDiff_EstimatesD6 = cbind(summary(modavg_widiv_QltyDiffD6)$coefmat.subset[,c(1,3)], confint(modavg_widiv_QltyDiffD6))
```
```{r}
widiv_QltyDiff_EstimatesD6
```
Borderline postive effect of Status

```{r}
boxplot(QltyDiff ~ Status, data = movedY_qlty_widiv_comp)
```
bigger variance of difference in site quality for divorced birds, and widowed birds moved to a better site as compared to divorced

```{r}
write.table(widiv_QltyDiff_EstimatesD6, "estimates_D6_widiv_QltyDiff_TBMU.csv",row.names = TRUE, sep = ",")
```


### Laying date difference

```{r}
lay_widiv_comp = widow_div_comp %>% dplyr::select(Band, Year, Site, Sex, LayingDiff, Status) %>% filter(!is.na(LayingDiff))
```

standardisation of the explanatory variables
```{r}
library(arm)
lay_widiv_comp = lay_widiv_comp %>% mutate(stdSex = rescale(Sex), stdStatus = rescale(Status))
```

how does the distribution of age difference look like
```{r}
with(lay_widiv_comp, hist(LayingDiff, breaks = 20))
```
alright

Having Year, Site and Band as random effects caused some convergence issues, so I don't consider Site as it has a variance almost equal to zero.
```{r}
widiv_LayingDiff = list()

library(glmmTMB)
widiv_LayingDiff[[1]] = glmmTMB(LayingDiff ~ stdSex * stdStatus + (1|Year) + (1|Band) + (1|Site), family = "gaussian", data = lay_widiv_comp)
widiv_LayingDiff[[2]] = glmmTMB(LayingDiff ~ stdSex + stdStatus + (1|Year) + (1|Band) + (1|Site), family = "gaussian", data = lay_widiv_comp)
widiv_LayingDiff[[3]] = glmmTMB(LayingDiff ~ stdSex +  (1|Year) + (1|Band) + (1|Site), family = "gaussian", data = lay_widiv_comp)
widiv_LayingDiff[[4]] = glmmTMB(LayingDiff ~ stdStatus +  (1|Year) + (1|Band) + (1|Site), family = "gaussian", data = lay_widiv_comp)
widiv_LayingDiff[[5]] = glmmTMB(LayingDiff ~ 1 + (1|Year) +  (1|Band) + (1|Site), family = "gaussian", data = lay_widiv_comp)
```

```{r}
hist(residuals(widiv_LayingDiff[[1]], type = "pearson"))
```
looks alright

Ranking all the models in increasing order of AICc and taking a subset to get to 95% of cumulative weights
```{r}
library(MuMIn)
AIC_widiv_LayingDiff = model.sel(widiv_LayingDiff, rank = "AICc")
modavg_widiv_LayingDiffD6 = model.avg(widiv_LayingDiff, beta = "none", subset = delta <= 6)
```

```{r, include=FALSE}
widiv_LayingDiff_EstimatesD6 = cbind(summary(modavg_widiv_LayingDiffD6)$coefmat.subset[,c(1,3)], confint(modavg_widiv_LayingDiffD6))
```
```{r}
widiv_LayingDiff_EstimatesD6
```
Positive effect of status!

```{r}
boxplot(LayingDiff ~ Status, data = lay_widiv_comp)
```
widowed birds laid later than divorced birds

```{r}
write.table(widiv_LayingDiff_EstimatesD6, "estimates_D6_widiv_LayingDiff_TBMU.csv",row.names = TRUE, sep = ",")
```


### Reprod success difference

```{r}
fledge_widiv_comp = widow_div_comp %>% dplyr::select(Band, Year, Site, Sex, FledgeDiff, Status) %>% filter(!is.na(FledgeDiff))
```

standardisation of the explanatory variables
```{r}
library(arm)
fledge_widiv_comp = fledge_widiv_comp %>% mutate(stdSex = rescale(Sex), stdStatus = rescale(Status), FledgeDiff = as.integer(if_else(FledgeDiff == -1, 0, if_else(FledgeDiff == 0, 0.5, 1))))
```


Having Year, Site and Band as random effects caused some convergence issues, so I don't consider Site as it has a variance almost equal to zero.
```{r}
widiv_FledgeDiff = list()

library(glmmTMB)
widiv_FledgeDiff[[1]] = glmmTMB(FledgeDiff ~ stdSex * stdStatus + (1|Year) + (1|Band) + (1|Site), family = "binomial", control = glmmTMBControl(optCtrl = list(iter.max = 1000, eval.max = 1000), profile = TRUE), data = fledge_widiv_comp)
widiv_FledgeDiff[[2]] = glmmTMB(FledgeDiff ~ stdSex + stdStatus + (1|Year) + (1|Band) + (1|Site), family = "binomial", control = glmmTMBControl(optCtrl = list(iter.max = 1000, eval.max = 1000), profile = TRUE), data = fledge_widiv_comp)
widiv_FledgeDiff[[3]] = glmmTMB(FledgeDiff ~ stdSex +  (1|Year) + (1|Band) + (1|Site), family = "binomial", control = glmmTMBControl(optCtrl = list(iter.max = 1000, eval.max = 1000), profile = TRUE), data = fledge_widiv_comp)
widiv_FledgeDiff[[4]] = glmmTMB(FledgeDiff ~ stdStatus +  (1|Year) + (1|Band) + (1|Site), family = "binomial", control = glmmTMBControl(optCtrl = list(iter.max = 1000, eval.max = 1000), profile = TRUE), data = fledge_widiv_comp)
widiv_FledgeDiff[[5]] = glmmTMB(FledgeDiff ~ 1 + (1|Year) +  (1|Band) + (1|Site), family = "binomial", control = glmmTMBControl(optCtrl = list(iter.max = 1000, eval.max = 1000), profile = TRUE), data = fledge_widiv_comp)
```

Check simulated residuals using DHARMa package. Doesn't work with models in list
```{r}
FledgeDiff_widiv_mod = glmmTMB(FledgeDiff ~ stdStatus +  (1|Year) + (1|Band) + (1|Site), family = "binomial", control = glmmTMBControl(optCtrl = list(iter.max = 1000, eval.max = 1000), profile = TRUE), data = fledge_widiv_comp)
summary(FledgeDiff_widiv_mod)

FledgeDiff_widiv_simres <- simulateResiduals(FledgeDiff_widiv_mod, n = 1000)

plot(FledgeDiff_widiv_simres)
```
strong pattern in the residuals...

Ranking all the models in increasing order of AICc and taking a subset to get to 95% of cumulative weights
```{r}
library(MuMIn)
AIC_widiv_FledgeDiff = model.sel(widiv_FledgeDiff, rank = "AICc")
modavg_widiv_FledgeDiffD6 = model.avg(widiv_FledgeDiff, beta = "none", subset = delta <= 6)
```

```{r, include=FALSE}
widiv_FledgeDiff_EstimatesD6 = cbind(summary(modavg_widiv_FledgeDiffD6)$coefmat.subset[,c(1,3)], confint(modavg_widiv_FledgeDiffD6))
```
```{r}
widiv_FledgeDiff_EstimatesD6
```
Negative effect of status!

```{r}
ggplot(data = fledge_widiv_comp, aes(y = FledgeDiff, x = Status)) + geom_jitter(height = 0.2)
```
widowed birds were more likely to not be successful with their new partner...

```{r}
write.table(widiv_FledgeDiff_EstimatesD6, "estimates_D6_widiv_FledgeDiff_TBMU.csv",row.names = TRUE, sep = ",")
```

## **c. Are there any advantages to remaining faithful?**

The goal is to compare pair-bond duration, average fledging success and laying date between pairs that divorced and pairs that ended because one individual died
```{r}
faithful_comp <- read.table("faithful_pair_TBMU.csv", header = TRUE, sep = ",")
```

Balance between divorce and disappearance
```{r}
with(faithful_comp, table(Outcome))
```

